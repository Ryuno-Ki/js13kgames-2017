<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JS13kgames 2017</title>
  <style type="text/css">
    body {
      background-color: white;
      color: black;
    }
  </style>
</head>
  <body>
    <h1>Canvas</h1>
    <canvas id="game"></canvas>

    <script type="text/javascript">
      (() => {
        class Game {
          addWall(wall) {
            this.walls.push(wall);
          }

          draw() {
            const context = this.context;
            context.clearRect(0, 0, this.width, this.height);
            this.drawWalls();
            this.hero.render(context);
          }

          drawWalls() {
            const x = this.width / 2;
            const y = this.height / 2;

            this.walls.forEach((wall) => {
              wall.render(this.context, x, y);
            });
          }

          getHeight() {
            return this.height;
          }

          getWidth() {
            return this.width;
          }

          init() {
            const fullCircleInRadians = 2 * Math.PI;
            const paddingBetweenWalls = 0.9 * 3 * fullCircleInRadians;
            this.setHero(new Hero(
              paddingBetweenWalls / 2,
              this.width / 2,
              this.height / 2,
            ));

            [1, 2, 3, 4, 5, 6].forEach((level) => {
              const wall = new Wall(level * paddingBetweenWalls);
              this.addWall(wall);
            });

            this.registerArrowKeyHandlers();
            window.requestAnimationFrame(this.update.bind(this));
          }

          registerArrowKeyHandlers() {
            const keymap = {
              'LEFT': 37,
              'UP': 38,
              'RIGHT': 39,
              'DOWN': 40,
            };

            document.body.addEventListener('keyup', (event) => {
              const key = event.keyCode;
              switch(key) {
                case keymap.LEFT:
                  this.hero.moveLeft();
                  break;
                case keymap.UP:
                  this.hero.moveUp();
                  break;
                case keymap.RIGHT:
                  this.hero.moveRight();
                  break;
                case keymap.DOWN:
                  this.hero.moveDown();
                  break;
                default:
                  console.log('Received keyCode', event.keyCode);
              }
              window.requestAnimationFrame(this.update.bind(this));
            }, false);
          }

          setHero(hero) {
            this.hero = hero;
          }

          update(timestamp) {
            let fps = 1 / 10 * 1000;  // in ms

            if (!this.step) {
              this.step = timestamp;
            }
            const progress = timestamp - this.step;

            fps = 5000;
            if (progress < fps) {
              console.log('Draw', progress);
              this.draw();
              window.requestAnimationFrame(this.update.bind(this));
            }
          }

          constructor(canvasId, height, width) {
            const canvas = document.getElementById('game');
            canvas.setAttribute('height', height + 'px');
            canvas.setAttribute('width', width + 'px');

            this.context = canvas.getContext('2d');
            this.element = canvas;
            this.height = parseInt(height, 10);
            this.width = parseInt(width, 10);

            this.hero = null;
            this.step = null;
            this.walls = [];
          }
        }

        class Hero {
          moveLeft() {
            this.x -= this.step;
          }

          moveRight() {
            this.x += this.step;
          }

          moveUp() {
            this.y -= this.step;
          }

          moveDown() {
            this.y += this.step;
          }

          render(context) {
            const fullCircleInRadians = 2 * Math.PI;
            const startAngle = 0;
            const endAngle = 0.9 * fullCircleInRadians;

            context.beginPath();
            context.arc(this.x, this.y, this.radius, startAngle, endAngle);
            context.fill();
          }

          constructor(diameter, x, y) {
            this.radius = diameter / 2;
            this.step = 5;
            this.x = x;
            this.y = y;
          }
        }

        class Wall {
          randomiseGate() {
            const fullCircleInRadians = 2 * Math.PI;
            const gate = Math.random() * fullCircleInRadians;
            const startAngle = 0 + gate;
            const endAngle = 0.9 * fullCircleInRadians + gate;

            return {
              end: endAngle,
              start: startAngle,
            }
          }

          render(context, x, y) {
            context.beginPath();
            context.arc(x, y, this.radius, this.startAngle, this.endAngle);
            context.stroke();
          }

          constructor(radius) {
            const { start, end } = this.randomiseGate();

            this.radius = radius;
            this.startAngle = start;
            this.endAngle = end;
          }
        }

        const game = new Game('game', 300, 300);
        game.init();
      })();
    </script>
  </body>
</html>
