{"version":3,"file":"index.js","sources":["../src/helper.js","../src/hero.js","../src/wall.js","../src/world.js","../src/game.js","../src/index.js"],"sourcesContent":["export class Helper {\n  static coordinationSystemToCenter(p, q) {\n    // (p, q) are measured from top-left corner\n    // (x, y) are center of circles\n    const x = p - World.WIDTH / 2;\n    const y = q - World.HEIGHT / 2;\n    return { x, y }\n  }\n\n  static mapCartesianToPolar(cartesian) {\n    const { x, y } = cartesian;\n    const r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n    const phi = Math.atan2(y, x);\n    return { r, phi };\n  }\n\n  static mapPolarToCartesian(polar) {\n      const { r, phi } = polar;\n      const x = r * Math.cos(phi);\n      const y = r * Math.sin(phi);\n      return { x, y };\n  }\n\n  static normaliseAngle(angle) {\n    const fullCircleInRadians = 2 * Math.PI;\n    /*\n    if (angle < 0) {\n      return (angle + fullCircleInRadians) % fullCircleInRadians\n    }\n    */\n    return angle % fullCircleInRadians;\n  }\n}\n","export class Hero {\n  moveLeft() {\n    this.x -= this.step;\n  }\n\n  moveRight() {\n    this.x += this.step;\n  }\n\n  moveUp() {\n    this.y -= this.step;\n  }\n\n  moveDown() {\n    this.y += this.step;\n  }\n\n  render(context) {\n    const fullCircleInRadians = 2 * Math.PI;\n    const startAngle = 0;\n    const endAngle = 0.9 * fullCircleInRadians;\n\n    context.beginPath();\n    context.arc(this.x, this.y, this.radius, startAngle, endAngle);\n    context.fill();\n  }\n\n  constructor(diameter, x, y) {\n    this.radius = diameter / 2;\n    this.step = 5;\n    this.x = x;\n    this.y = y;\n  }\n}\n","export class Wall {\n  randomiseGate() {\n    const fullCircleInRadians = 2 * Math.PI;\n    const gate = Math.random() * fullCircleInRadians;\n    const startAngle = 0 + gate;\n    const endAngle = Helper.normaliseAngle(startAngle + 0.1 * fullCircleInRadians);\n\n    return {\n      end: endAngle,\n      start: startAngle,\n    }\n  }\n\n  render(context, x, y) {\n    // Since the gate shall be spared out from circle, switch its start\n    // and end when drawing the arc\n    context.beginPath();\n    context.arc(x, y, this.radius, this.endGate, this.startGate);\n    context.stroke();\n  }\n\n  constructor(radius) {\n    const { start, end } = this.randomiseGate();\n\n    this.radius = radius;\n    this.startGate = start;\n    this.endGate = end;\n  }\n}\n","export class World {\n  static get HEIGHT() {\n    return 300;\n  }\n\n  static get WIDTH() {\n    return 300;\n  }\n}\n","import { Helper } from './helper';\nimport { Hero } from './hero';\nimport { Swipe } from './swipe';\nimport { Wall } from './wall';\nimport { World } from './world';\n\nexport class Game {\n  addWall(wall) {\n    this.walls.push(wall);\n  }\n\n  compareAngle() {\n    const hero = this.hero;\n    const position = Helper.mapCartesianToPolar(\n      Helper.coordinationSystemToCenter(hero.x, hero.y)\n    );\n    const positionOfHero = position.r + hero.radius;\n    const paddingBetweenWalls = this.paddingBetweenWalls;\n\n    const collision = this.walls.filter((wall) => {\n      // Only need to look at adjacent walls\n      if (positionOfHero - wall.radius > paddingBetweenWalls) {\n        return false;\n      }\n      if (wall.radius - positionOfHero > paddingBetweenWalls) {\n        return false;\n      }\n      return true;\n    }).map((wall) => {\n      // atan2 (hero) is measuring from x-axis counterclockwise\n      // canvas is drawing from x-axis clockwise\n      // hence, translate hero and normalise angles\n      const startGate = Helper.normaliseAngle(wall.startGate)\n      const endGate = Helper.normaliseAngle(wall.endGate);\n      const heroAngle = Helper.normaliseAngle(2*Math.PI - position.phi);\n\n      if (startGate < heroAngle && endGate > heroAngle) {\n        return false;\n      }\n      return true;\n    }).reduce((summary, current) => {\n      return summary || current;\n    });\n    return true;\n  }\n\n  compareRadii() {\n    const hero = this.hero;\n    const position = Helper.mapCartesianToPolar(\n      Helper.coordinationSystemToCenter(hero.x, hero.y)\n    );\n    const positionOfHero = position.r + hero.radius;\n    const paddingBetweenWalls = this.paddingBetweenWalls;\n\n    const collision = this.walls.map((wall) => {\n      // Only need to compare radius\n      return wall.radius;\n    }).filter((wallRadius) => {\n      // Only need to look at adjacent walls\n      if (positionOfHero - wallRadius > paddingBetweenWalls) {\n        return false;\n      }\n      if (wallRadius - positionOfHero > paddingBetweenWalls) {\n        return false;\n      }\n      return true;\n    }).map((wallRadius) => {\n      // Does hero circle intersect with wall?\n      if (position.r - hero.radius > wallRadius) {\n        return false;\n      }\n      if (position.r + hero.radius < wallRadius) {\n        return false;\n      }\n      return true;\n    }).reduce((summary, intersection) => {\n      // Is any value true?\n      return summary || intersection;\n    });\n    return collision;\n  }\n\n  detectCollision() {\n    return this.compareAngle() && this.compareRadii();\n  }\n\n  draw() {\n    const context = this.context;\n    if (this.detectCollision()) {\n      console.warn('Code RED');\n    }\n    context.clearRect(0, 0, this.width, this.height);\n    this.drawWalls();\n    this.hero.render(context);\n  }\n\n  drawWalls() {\n    const x = this.width / 2;\n    const y = this.height / 2;\n\n    this.walls.forEach((wall) => {\n      wall.render(this.context, x, y);\n    });\n  }\n\n  init() {\n    this.setHero(new Hero(\n      this.paddingBetweenWalls / 2,\n      this.width / 2,\n      this.height / 2,\n    ));\n\n    [1, 2, 3, 4, 5, 6].forEach((level) => {\n      const wall = new Wall(level * this.paddingBetweenWalls);\n      this.addWall(wall);\n    });\n\n    this.registerArrowKeyHandlers();\n    this.registerSwipeHandlers();\n    window.requestAnimationFrame(this.update.bind(this));\n  }\n\n  registerArrowKeyHandlers() {\n    const keymap = {\n      'LEFT': 37,\n      'UP': 38,\n      'RIGHT': 39,\n      'DOWN': 40,\n    };\n\n    document.body.addEventListener('keydown', (event) => {\n      const key = event.keyCode;\n      switch(key) {\n        case keymap.LEFT:\n          this.hero.moveLeft();\n          event.preventDefault();\n          break;\n        case keymap.UP:\n          this.hero.moveUp();\n          event.preventDefault();\n          break;\n        case keymap.RIGHT:\n          this.hero.moveRight();\n          event.preventDefault();\n          break;\n        case keymap.DOWN:\n          this.hero.moveDown();\n          event.preventDefault();\n          break;\n        default:\n          console.log('Received keyCode', event.keyCode);\n      }\n      window.requestAnimationFrame(this.update.bind(this));\n    }, false);\n  }\n\n  registerSwipeHandlers() {\n    const swiper = new Swiper(this.element);\n    swiper.onLeft(() => {\n      console.log('Swiped left');\n    });\n  }\n\n  setHero(hero) {\n    this.hero = hero;\n  }\n\n  update(timestamp) {\n    const fps = 60;\n    const progress = timestamp - this.lastUpdateTimestamp;\n    const isInitialDraw = progress < 0;\n\n    if (progress > fps || isInitialDraw) {\n      this.draw();\n      window.requestAnimationFrame(this.update.bind(this));\n      this.lastUpdateTimestamp = timestamp;\n    }\n  }\n\n  constructor(canvasId) {\n    const canvas = document.getElementById('game');\n    const height = World.HEIGHT;\n    const width = World.WIDTH;\n    canvas.setAttribute('height', height + 'px');\n    canvas.setAttribute('width', width + 'px');\n\n    this.context = canvas.getContext('2d');\n    this.element = canvas;\n    this.height = parseInt(height, 10);\n    this.width = parseInt(width, 10);\n\n    this.hero = null;\n    this.lastUpdateTimestamp = Number(new Date());\n    this.walls = [];\n\n    const fullCircleInRadians = 2 * Math.PI;\n    this.paddingBetweenWalls = 0.9 * 3 * fullCircleInRadians;\n  }\n}\n","import { Game } from './game.js';\n\nconst game = new Game('game');\ngame.init();\n"],"names":["Helper","[object Object]","p","q","x","World","WIDTH","y","HEIGHT","cartesian","r","Math","sqrt","pow","phi","atan2","polar","cos","sin","angle","PI","Hero","this","step","context","endAngle","beginPath","arc","radius","fill","diameter","Wall","fullCircleInRadians","startAngle","random","end","normaliseAngle","start","endGate","startGate","stroke","randomiseGate","Game","wall","walls","push","hero","position","mapCartesianToPolar","coordinationSystemToCenter","positionOfHero","paddingBetweenWalls","filter","map","heroAngle","reduce","summary","current","wallRadius","intersection","compareAngle","compareRadii","detectCollision","console","warn","clearRect","width","height","drawWalls","render","forEach","setHero","level","addWall","registerArrowKeyHandlers","registerSwipeHandlers","window","requestAnimationFrame","update","bind","keymap","LEFT","UP","RIGHT","DOWN","document","body","addEventListener","event","keyCode","moveLeft","preventDefault","moveUp","moveRight","moveDown","log","Swiper","element","onLeft","timestamp","progress","lastUpdateTimestamp","isInitialDraw","draw","canvasId","canvas","getElementById","setAttribute","getContext","parseInt","Number","Date","init"],"mappings":"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"}