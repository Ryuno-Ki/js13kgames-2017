var game=function(t){"use strict";function e(t,e){if(!t)return o;switch(e.type){case r.moveDown:case r.moveLeft:case r.moveRight:case r.moveUp:return Object.assign({},t,e.payload);default:return t}}function s(t,e){if(!t)return h;switch(e.type){case l.add:case l.randomiseGate:case l.setRadius:return Object.assign({},t,e.payload);default:return t}}class a{static create(t){const e=a.createCanvas(t);return window.document.body.appendChild(e),e}static createCanvas(t){const e=window.document.createElement("canvas");return e.setAttribute("id",t),e.setAttribute("height",`${a.HEIGHT}px`),e.setAttribute("width",`${a.WIDTH}px`),e}static get GATESIZE(){return 1.05*a.USERSIZE}static get HEIGHT(){return Math.min(window.innerHeight,window.innerWidth)}static get USERSIZE(){return a.WALLDISTANCE/3}static get USERROTATION(){const t=window.document.getElementById("angle");if(null===t)return console.log("Fallback USERROTATION"),.02*n.euclideanDistance(a.HEIGHT,a.WIDTH);const e=parseInt(t.value,10);return n.mapDegreeToRadians(e)}static get USERVELOCITY(){return 3}static get WALLDISTANCE(){return.06*(a.HEIGHT+a.WIDTH)/2}static get WIDTH(){return Math.min(window.innerHeight,window.innerWidth)}render(t){const e=this.context,s=t.walls.walls;e.clearRect(0,0,a.WIDTH,a.HEIGHT),s.forEach(t=>{this.renderWall(t)}),this.renderHero(t.user)}renderHero(t){const e=.9*(2*Math.PI),s=a.USERSIZE,r=this.context,i=n.mapPolarToCartesian({r:t.radius,phi:t.angle}),o=n.coordinationSystemToVertex(i.x,i.y),c=o.p,d=o.q;r.beginPath(),r.arc(c,d,s,0,e),r.fill()}renderWall(t){const e=a.WIDTH/2,s=a.HEIGHT/2,n=this.context,r=t.gate.end,i=t.gate.start,o=t.radius;n.beginPath(),n.arc(e,s,o,r,i),n.stroke()}constructor(t){this.element=a.create(t),this.context=this.element.getContext("2d")}}class n{static coordinationSystemToCenter(t,e){return{x:t-a.WIDTH/2,y:e-a.HEIGHT/2}}static coordinationSystemToVertex(t,e){return{p:t+a.WIDTH/2,q:e+a.HEIGHT/2}}static euclideanDistance(t,e){return Math.sqrt(t*t+e*e)}static mapCartesianToPolar(t){const e=t.x,s=t.y;return{r:Math.sqrt(Math.pow(e,2)+Math.pow(s,2)),phi:Math.atan2(s,e)}}static mapDegreeToRadians(t){return t*Math.PI/180}static mapPolarToCartesian(t){const e=t.phi,s=t.r;return{x:s*Math.cos(e),y:s*Math.sin(e)}}static mapRadiansToDegree(t){return 180*t/Math.PI}static normaliseAngle(t){const e=2*Math.PI;return t<0?(t+e)%e:t%e}}class r{static get moveDown(){return"HERO_MOVES_DOWN"}static get moveLeft(){return"HERO_MOVES_LEFT"}static get moveRight(){return"HERO_MOVES_RIGHT"}static get moveUp(){return"HERO_MOVES_UP"}}class i{static moveDown(t){const e=t.distance;return{type:r.moveDown,payload:{radius:t.radius-e}}}static moveLeft(t){const e=n.mapDegreeToRadians(3*t.distance);return{type:r.moveLeft,payload:{angle:t.angle-e}}}static moveRight(t){const e=n.mapDegreeToRadians(3*t.distance);return{type:r.moveRight,payload:{angle:t.angle+e}}}static moveUp(t){const e=t.distance;return{type:r.moveUp,payload:{radius:t.radius+e}}}}const o={angle:0,radius:0};class c{static createStore(t,e){const s=t(e,{type:"DUMMY",payload:{}}),a=Object.assign({},s,e);return new c(t,a)}static reduceReducers(t){return(e,s)=>{const a={};return Object.keys(t).forEach(n=>{const r=(0,t[n])(e?e[n]:null,s);a[n]=r}),a}}dispatch(t){const e=this.getState(),s=this._reducer(e,t);this._state=s,this._subscribers.forEach(t=>{t(s)})}getState(){return this._state}subscribe(t){this._subscribers.push(t);return()=>this._subscribers}constructor(t,e){const s=e||{};this._state=Object.assign({},s),this._reducer=t,this._subscribers=[]}}class d{handleTouchMove(t){if(!this.xDown||!this.yDown)return;const e=this.handlers,s=t.touches[0].clientX,a=t.touches[0].clientY;this.xDiff=this.xDown-s,this.yDiff=this.yDown-a,Math.abs(this.xDiff)>Math.abs(this.yDiff)?this.xDiff>0?e.onLeft(this.xDiff):e.onRight(this.xDiff):this.yDiff>0?e.onUp(this.yDiff):e.onDown(this.yDiff),this.xDown=null,this.yDown=null}onTouchMove(t){this.handleTouchMove(t)}onTouchStart(t){this.xDown=t.touches[0].clientX,this.yDown=t.touches[0].clientY}run(){const t=this,e=t.onTouchMove;this.element.addEventListener("touchmove",e.bind(t),!1)}constructor(t,e){this.xDown=null,this.yDown=null,this.element=t,this.element.addEventListener("touchstart",this.onTouchStart.bind(this),!1);const s=e.onDown,a=e.onLeft,n=e.onRight,r=e.onUp;this.handlers={onDown:s,onLeft:a,onRight:n,onUp:r}}}class l{static get add(){return"WALL_ADD"}static get randomiseGate(){return"WALL_RANDOMISE_GATE"}static get setRadius(){return"WALL_SET_RADIUS"}}class u{static _getRandomStart(){return 2*Math.PI*Math.random()}static _getRandomEnd(t,e){return n.normaliseAngle(t+e)}static add(t){const e=t.walls.slice(),s=Object.assign({},u.randomiseGate(t.width).payload,u.setRadius(t.radius).payload),a={walls:e.concat(s)};return Object.assign({},t,{type:l.add,payload:a})}static randomiseGate(t){const e=u._getRandomStart(),s=u._getRandomEnd(e,t);return{type:l.randomiseGate,payload:{gate:{start:e,end:s}}}}static setRadius(t){return{type:l.setRadius,payload:{radius:t}}}}const h={walls:[{radius:a.WALLDISTANCE,gate:{end:a.GATESIZE,start:0}}]};class g{static get KEYMAP(){return{LEFT:37,UP:38,RIGHT:39,DOWN:40}}static notifyUser(){window.document.body.classList.add("flash"),setTimeout(()=>{window.document.body.classList.remove("flash")},500)}static compareAngle(t,e){const s=t.radius+a.USERSIZE,r=a.WALLDISTANCE;return e.filter(t=>!(s-t.radius>r)&&!(t.radius-s>r)).map(e=>{const s=n.normaliseAngle(e.gate.start),a=n.normaliseAngle(e.gate.end),r=n.normaliseAngle(t.angle);return!(s<r&&a>r)}).reduce((t,e)=>t||e)}static compareRadii(t,e){const s=t.radius+a.USERSIZE,n=a.WALLDISTANCE;return e.map(t=>t.radius).filter(t=>!(s-t>n)&&!(t-s>n)).map(t=>!(s+a.USERSIZE<t)&&!(s-a.USERSIZE>t)).reduce((t,e)=>t||e)}static detectCollision(t){const e=t.user,s=t.walls.walls,a=g.compareAngle(e,s),n=g.compareRadii(e,s);return a&&n}static update(t,e){const s=e.getState();g.detectCollision(s)&&g.notifyUser(),t.render(e.getState())}static _buildHeroPayload(t,e){return Object.assign({},t.user,{distance:e})}init(){this.store.dispatch({},{type:"INIT",payload:{}});let t,e,s;for(let n=2;n<6;n++)s={walls:e=(t=this.store.getState()).walls.walls,radius:n*a.WALLDISTANCE,width:a.GATESIZE},this.store.dispatch(u.add(s));this.registerArrowKeyHandlers(),this.registerSwipeHandlers(),t=this.store.getState(),s=g._buildHeroPayload(t,5),this.store.dispatch(i.moveUp(s))}onKeyDown(t){const e=t.keyCode,s=g.KEYMAP,a=this.store,n=a.getState(),r=g._buildHeroPayload(n,5);switch(e){case s.LEFT:a.dispatch(i.moveLeft(r)),t.preventDefault();break;case s.UP:a.dispatch(i.moveUp(r)),t.preventDefault();break;case s.RIGHT:a.dispatch(i.moveRight(r)),t.preventDefault();break;case s.DOWN:a.dispatch(i.moveDown(r)),t.preventDefault();break;default:console.log("Received keyCode",t.keyCode)}}registerArrowKeyHandlers(){const t=this,e=this.onKeyDown;window.document.body.addEventListener("keydown",e.bind(t),!1)}registerSwipeHandlers(){const t=this.store,e={onDown:e=>{const s=t.getState(),a=g._buildHeroPayload(s,e);t.dispatch(i.moveDown(a))},onLeft:e=>{const s=t.getState(),a=g._buildHeroPayload(s,e);t.dispatch(i.moveLeft(a))},onRight:e=>{const s=t.getState(),a=g._buildHeroPayload(s,e);t.dispatch(i.moveRight(a))},onUp:e=>{const s=t.getState(),a=g._buildHeroPayload(s,e);t.dispatch(i.moveUp(a))}};new d(this.world.element,e).run()}constructor(t){const n={user:e,walls:s},r=c.reduceReducers(n);this.store=c.createStore(r),this.world=new a(t),this.store.subscribe(()=>{g.update(this.world,this.store)})}}return new g("game").init(),t.Game=g,t}({});
