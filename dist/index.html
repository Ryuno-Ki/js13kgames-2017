<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>JS13kgames 2017</title> <style type="text/css"> body{ background-color:white;color:black;}</style> </head> <body> <h1>Canvas</h1> <canvas id="game"></canvas> <script type="text/javascript">(() => {
        class Game {
          addWall(wall) {
            this.walls.push(wall);
          }

          compareAngle() {
            const hero = this.hero;
            const position = Helper.mapCartesianToPolar(
              Helper.coordinationSystemToCenter(hero.x, hero.y)
            );
            const positionOfHero = position.r + hero.radius;
            const paddingBetweenWalls = this.paddingBetweenWalls;

            const collision = this.walls.filter((wall) => {
              // Only need to look at adjacent walls
              if (positionOfHero - wall.radius > paddingBetweenWalls) {
                return false;
              }
              if (wall.radius - positionOfHero > paddingBetweenWalls) {
                return false;
              }
              return true;
            }).map((wall) => {
              // atan2 (hero) is measuring from x-axis counterclockwise
              // canvas is drawing from x-axis clockwise
              // hence, translate hero and normalise angles
              const startGate = Helper.normaliseAngle(wall.startGate)
              const endGate = Helper.normaliseAngle(wall.endGate);
              const heroAngle = Helper.normaliseAngle(2*Math.PI - position.phi);

              if (startGate < heroAngle && endGate > heroAngle) {
                return false;
              }
              return true;
            }).reduce((summary, current) => {
              return summary || current;
            });
            return true;
          }

          compareRadii() {
            const hero = this.hero;
            const position = Helper.mapCartesianToPolar(
              Helper.coordinationSystemToCenter(hero.x, hero.y)
            );
            const positionOfHero = position.r + hero.radius;
            const paddingBetweenWalls = this.paddingBetweenWalls;

            const collision = this.walls.map((wall) => {
              // Only need to compare radius
              return wall.radius;
            }).filter((wallRadius) => {
              // Only need to look at adjacent walls
              if (positionOfHero - wallRadius > paddingBetweenWalls) {
                return false;
              }
              if (wallRadius - positionOfHero > paddingBetweenWalls) {
                return false;
              }
              return true;
            }).map((wallRadius) => {
              // Does hero circle intersect with wall?
              if (position.r - hero.radius > wallRadius) {
                return false;
              }
              if (position.r + hero.radius < wallRadius) {
                return false;
              }
              return true;
            }).reduce((summary, intersection) => {
              // Is any value true?
              return summary || intersection;
            });
            return collision;
          }

          detectCollision() {
            return this.compareAngle() && this.compareRadii();
          }

          draw() {
            const context = this.context;
            if (this.detectCollision()) {
              console.warn('Code RED');
            }
            context.clearRect(0, 0, this.width, this.height);
            this.drawWalls();
            this.hero.render(context);
          }

          drawWalls() {
            const x = this.width / 2;
            const y = this.height / 2;

            this.walls.forEach((wall) => {
              wall.render(this.context, x, y);
            });
          }

          init() {
            this.setHero(new Hero(
              this.paddingBetweenWalls / 2,
              this.width / 2,
              this.height / 2,
            ));

            [1, 2, 3, 4, 5, 6].forEach((level) => {
              const wall = new Wall(level * this.paddingBetweenWalls);
              this.addWall(wall);
            });

            this.registerArrowKeyHandlers();
            window.requestAnimationFrame(this.update.bind(this));
          }

          registerArrowKeyHandlers() {
            const keymap = {
              'LEFT': 37,
              'UP': 38,
              'RIGHT': 39,
              'DOWN': 40,
            };

            document.body.addEventListener('keydown', (event) => {
              const key = event.keyCode;
              switch(key) {
                case keymap.LEFT:
                  this.hero.moveLeft();
                  event.preventDefault();
                  break;
                case keymap.UP:
                  this.hero.moveUp();
                  event.preventDefault();
                  break;
                case keymap.RIGHT:
                  this.hero.moveRight();
                  event.preventDefault();
                  break;
                case keymap.DOWN:
                  this.hero.moveDown();
                  event.preventDefault();
                  break;
                default:
                  console.log('Received keyCode', event.keyCode);
              }
              window.requestAnimationFrame(this.update.bind(this));
            }, false);
          }

          setHero(hero) {
            this.hero = hero;
          }

          update(timestamp) {
            const fps = 60;
            const progress = timestamp - this.lastUpdateTimestamp;
            const isInitialDraw = progress < 0;

            if (progress > fps || isInitialDraw) {
              this.draw();
              window.requestAnimationFrame(this.update.bind(this));
              this.lastUpdateTimestamp = timestamp;
            }
          }

          constructor(canvasId) {
            const canvas = document.getElementById('game');
            const height = World.HEIGHT;
            const width = World.WIDTH;
            canvas.setAttribute('height', height + 'px');
            canvas.setAttribute('width', width + 'px');

            this.context = canvas.getContext('2d');
            this.element = canvas;
            this.height = parseInt(height, 10);
            this.width = parseInt(width, 10);

            this.hero = null;
            this.lastUpdateTimestamp = Number(new Date());
            this.walls = [];

            const fullCircleInRadians = 2 * Math.PI;
            this.paddingBetweenWalls = 0.9 * 3 * fullCircleInRadians;
          }
        }

        class Helper {
          static coordinationSystemToCenter(p, q) {
            // (p, q) are measured from top-left corner
            // (x, y) are center of circles
            const x = p - World.WIDTH / 2;
            const y = q - World.HEIGHT / 2;
            return { x, y }
          }

          static mapCartesianToPolar(cartesian) {
            const { x, y } = cartesian;
            const r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
            const phi = Math.atan2(y, x);
            return { r, phi };
          }

          static mapPolarToCartesian(polar) {
              const { r, phi } = polar;
              const x = r * Math.cos(phi);
              const y = r * Math.sin(phi);
              return { x, y };
          }

          static normaliseAngle(angle) {
            const fullCircleInRadians = 2 * Math.PI;
            /*
            if (angle < 0) {
              return (angle + fullCircleInRadians) % fullCircleInRadians
            }
            */
            return angle % fullCircleInRadians;
          }
        }

        class Hero {
          moveLeft() {
            this.x -= this.step;
          }

          moveRight() {
            this.x += this.step;
          }

          moveUp() {
            this.y -= this.step;
          }

          moveDown() {
            this.y += this.step;
          }

          render(context) {
            const fullCircleInRadians = 2 * Math.PI;
            const startAngle = 0;
            const endAngle = 0.9 * fullCircleInRadians;

            context.beginPath();
            context.arc(this.x, this.y, this.radius, startAngle, endAngle);
            context.fill();
          }

          constructor(diameter, x, y) {
            this.radius = diameter / 2;
            this.step = 5;
            this.x = x;
            this.y = y;
          }
        }

        class Wall {
          randomiseGate() {
            const fullCircleInRadians = 2 * Math.PI;
            const gate = Math.random() * fullCircleInRadians;
            const startAngle = 0 + gate;
            const endAngle = Helper.normaliseAngle(startAngle + 0.1 * fullCircleInRadians);

            return {
              end: endAngle,
              start: startAngle,
            }
          }

          render(context, x, y) {
            // Since the gate shall be spared out from circle, switch its start
            // and end when drawing the arc
            context.beginPath();
            context.arc(x, y, this.radius, this.endGate, this.startGate);
            context.stroke();
          }

          constructor(radius) {
            const { start, end } = this.randomiseGate();

            this.radius = radius;
            this.startGate = start;
            this.endGate = end;
          }
        }

        class World {
          static get HEIGHT() {
            return 300;
          }

          static get WIDTH() {
            return 300;
          }
        }

        const game = new Game('game');
        game.init();
      })();</script> </body> </html> 
